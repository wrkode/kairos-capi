#cloud-config

{{- /* 
Template inputs (from Go):

  .Role              string   // "control-plane" or "worker"
  .ControlPlaneMode  string   // "init" or "join" (control-plane only)
  .SingleNode        bool     // true for single-node k0s (controller-only)
  .Hostname          string   // explicit hostname (optional)
  .UserName          string   // e.g. "kairos"
  .UserPassword      string   // e.g. "kairos"
  .UserGroups        []string // e.g. ["admin"]
  .GitHubUser        string   // e.g. "YOUR_GITHUB_USER" (optional)
  .SSHPublicKey      string   // alternative to GitHubUser (optional)
  .WorkerToken       string   // used only for workers
  .ControlPlaneJoinToken string // used for control-plane join
  .Manifests         []Manifest // optional manifests
  .HostnamePrefix    string   // e.g. "metal-"
  .DNSServers        []string // optional DNS resolvers
  .Install           *InstallConfig // install configuration (optional)
  .ProviderID        string   // providerID for Node (e.g., "vsphere://<vm-uuid>")
*/ -}}

{{- $isJoin := and (eq .ControlPlaneMode "join") (not .SingleNode) }}

{{/* Hostname: prefer explicit name, else use hostname prefix with Kairos templating for machine ID */}}
{{/* The {{ trunc 4 .MachineID }} is Kairos templating syntax, output literally */}}
{{- if .Hostname }}
hostname: {{ .Hostname }}
{{- else if .HostnamePrefix }}
hostname: {{ .HostnamePrefix }}{{ "{{ trunc 4 .MachineID }}" }}
{{- end }}

{{- if and .Install .Install.Auto }}
install:
  auto: {{ .Install.Auto }}
  device: "{{ .Install.Device }}"
  reboot: {{ .Install.Reboot }}
{{- end }}

users:
- name: {{ .UserName }}
  passwd: {{ .UserPassword }}
  groups:
  {{- range .UserGroups }}
    - {{ . }}
  {{- end }}
  {{- if or .GitHubUser .SSHPublicKey }}
  ssh_authorized_keys:
  {{- if .GitHubUser }}
    - github:{{ .GitHubUser }}
  {{- end }}
  {{- if .SSHPublicKey }}
    - {{ .SSHPublicKey }}
  {{- end }}
  {{- end }}
- name: capk
  groups: [users, admin]

{{- if eq .Role "control-plane" }}

# Control-plane node configuration
k0s:
  enabled: true
  {{- if or .SingleNode .PodCIDR .ServiceCIDR .IsKubeVirt $isJoin }}
  args:
  {{- if .SingleNode }}
    - --single
  {{- end }}
  {{- if $isJoin }}
    - --token-file /etc/k0s/controller-token
  {{- end }}
  {{- if or .PodCIDR .ServiceCIDR .IsKubeVirt }}
    - --config /etc/k0s/k0s.yaml
  {{- end }}
  {{- end }}

{{- else }}

# Worker node configuration
k0s-worker:
  enabled: true
  args:
    - --token-file /etc/k0s/token

{{- end }}

{{- if or .IsKubeVirt (and (eq .Role "control-plane") (or .PodCIDR .ServiceCIDR (and $isJoin .ControlPlaneJoinToken))) (and (ne .Role "control-plane") .WorkerToken) }}
write_files:
  {{- if and (eq .Role "control-plane") (or .PodCIDR .ServiceCIDR .IsKubeVirt) }}
  - path: /etc/k0s/k0s.yaml
    permissions: "0644"
    content: |
      apiVersion: k0s.k0sproject.io/v1beta1
      kind: ClusterConfig
      metadata:
        name: k0s
      {{- if or .PodCIDR .ServiceCIDR .ControlPlaneLBEndpoint }}
      spec:
      {{- if .ControlPlaneLBEndpoint }}
        api:
          sans:
            - {{ .ControlPlaneLBEndpoint }}
      {{- end }}
      {{- if or .PodCIDR .ServiceCIDR }}
        network:
      {{ if .PodCIDR }}
          podCIDR: {{ .PodCIDR }}
      {{ end }}
      {{ if .ServiceCIDR }}
          serviceCIDR: {{ .ServiceCIDR }}
      {{ end }}
      {{- end }}
      {{- else }}
      spec: {}
      {{- end }}
  {{- end }}
  {{- if and (eq .Role "control-plane") $isJoin .ControlPlaneJoinToken }}
  - path: /etc/k0s/controller-token
    permissions: "0644"
    content: |
      {{ .ControlPlaneJoinToken }}
  {{- end }}
  {{- if and (ne .Role "control-plane") .WorkerToken }}
  - path: /etc/k0s/token
    permissions: "0644"
    content: |
      {{ .WorkerToken }}
  {{- end }}
  {{- if .IsKubeVirt }}
  - path: /etc/systemd/system/kairos-k0s-post-bootstrap.service
    permissions: "0644"
    owner: 0
    group: 0
    content: |
      [Unit]
      Description=Kairos k0s post-bootstrap tasks
      {{- if eq .Role "control-plane" }}
      After=k0s.service
      Wants=k0s.service
      {{- else }}
      After=k0s-worker.service
      Wants=k0s-worker.service
      {{- end }}
      
      [Service]
      Type=oneshot
      RemainAfterExit=yes
      ExecStart=/usr/local/bin/kairos-k0s-post-bootstrap.sh
      
      [Install]
      WantedBy=multi-user.target
  - path: /usr/local/bin/kairos-k0s-post-bootstrap.sh
    permissions: "0755"
    owner: 0
    group: 0
    content: |
      #!/bin/bash
      set -e
      
      # CAPK: always mark bootstrap success on script exit
      mark_bootstrap_success() {
        mkdir -p /run/cluster-api
        echo "success" > /run/cluster-api/bootstrap-success.complete
        chmod 0644 /run/cluster-api/bootstrap-success.complete
      }
      trap mark_bootstrap_success EXIT
      
      {{- if .HostnamePrefix }}
      # Enforce hostname from cloud-config on immutable rootfs
      if [ -f /usr/local/etc/hostname ]; then
        /usr/bin/hostnamectl set-hostname "$(cat /usr/local/etc/hostname)"
        if ! grep -qE "127\.0\.1\.1[[:space:]]+$(cat /usr/local/etc/hostname)" /etc/hosts; then
          echo "127.0.1.1 $(cat /usr/local/etc/hostname)" >> /etc/hosts
        fi
      fi
      {{- end }}

      {{- if and .IsKubeVirt (eq .Role "control-plane") }}
      # KubeVirt: ensure the API server cert includes the node IP (pod or bridged)
      # This prevents TLS SAN mismatch when CAPI connects to the workload cluster.
      {{- if .PrimaryIP }}
      KAIROS_PRIMARY_IP="{{ .PrimaryIP }}"
      {{- end }}
      {{- if .MachineName }}
      KAIROS_VMI_NAME="{{ .MachineName }}"
      {{- end }}
      {{- if .ClusterNS }}
      KAIROS_VMI_NAMESPACE="{{ .ClusterNS }}"
      {{- end }}
      {{- if .ManagementKubeconfigToken }}
      KAIROS_MGMT_API="{{ .ManagementAPIServer }}"
      KAIROS_MGMT_TOKEN="{{ .ManagementKubeconfigToken }}"
      {{- end }}
      fetch_vmi_ip_from_management() {
        if [ -z "${KAIROS_MGMT_API}" ] || [ -z "${KAIROS_MGMT_TOKEN}" ] || [ -z "${KAIROS_VMI_NAME}" ] || [ -z "${KAIROS_VMI_NAMESPACE}" ]; then
          return 1
        fi
        if ! command -v curl >/dev/null 2>&1; then
          return 1
        fi
        local url="${KAIROS_MGMT_API}/apis/kubevirt.io/v1/namespaces/${KAIROS_VMI_NAMESPACE}/virtualmachineinstances/${KAIROS_VMI_NAME}"
        local json
        json=$(curl -k -sS -H "Authorization: Bearer ${KAIROS_MGMT_TOKEN}" "${url}" 2>/dev/null || true)
        if [ -z "${json}" ]; then
          return 1
        fi
        local ip
        ip=$(echo "${json}" | sed -n 's/.*"ipAddress":"\\([^"]*\\)".*/\\1/p' | head -n1)
        if [ -n "${ip}" ]; then
          echo "${ip}"
          return 0
        fi
        return 1
      }
      detect_primary_ip_once() {
        if [ -n "${KAIROS_PRIMARY_IP}" ]; then
          echo "Using primary IP override: ${KAIROS_PRIMARY_IP}"
          echo "${KAIROS_PRIMARY_IP}"
          return 0
        fi
        local mgmt_ip=""
        mgmt_ip=$(fetch_vmi_ip_from_management || true)
        if [ -n "${mgmt_ip}" ]; then
          echo "Using VMI IP from management API: ${mgmt_ip}"
          echo "${mgmt_ip}"
          return 0
        fi
        local dev=""
        local ip=""
        dev=$(ip -4 route show default 2>/dev/null | awk '{print $5; exit}')
        if [ -n "${dev}" ]; then
          ip=$(ip -4 -o addr show dev "${dev}" scope global 2>/dev/null | awk '{print $4}' | cut -d/ -f1 | head -n1)
        fi
        if [ -z "${ip}" ]; then
          ip=$(ip -4 -o addr show scope global 2>/dev/null | awk '{print $4}' | cut -d/ -f1 | head -n1)
        fi
        if [ -n "${ip}" ]; then
          echo "Using detected guest IP: ${ip}"
        fi
        echo "${ip}"
      }
      detect_primary_ip() {
        local ip=""
        for i in {1..30}; do
          ip="$(detect_primary_ip_once)"
          if [ -n "${ip}" ]; then
            echo "${ip}"
            return 0
          fi
          echo "Waiting for primary IP... (${i}/30)"
          sleep 5
        done
        return 1
      }

      KAIROS_SANS_CHANGED=0
      ensure_k0s_api_sans() {
        local api_ip="$1"
        if [ -z "${api_ip}" ]; then
          echo "WARN: unable to detect node IP for k0s api.sans"
          return 1
        fi

        local cfg="/etc/k0s/k0s.yaml"
        if [ ! -f "${cfg}" ]; then
          printf '%s\n' \
            "apiVersion: k0s.k0sproject.io/v1beta1" \
            "kind: ClusterConfig" \
            "metadata:" \
            "  name: k0s" \
            "spec:" \
            "  api:" \
            "    sans:" \
            "    - ${api_ip}" > "${cfg}"
          KAIROS_SANS_CHANGED=1
          return 0
        fi

        if grep -qE '^[[:space:]]*api:' "${cfg}"; then
          if grep -qE '^[[:space:]]*sans:' "${cfg}"; then
            if ! grep -qE '^[[:space:]]*-[[:space:]]*'"${api_ip}"'([[:space:]]|$)' "${cfg}"; then
              sed -i "/^[[:space:]]*sans:/a\\    - ${api_ip}" "${cfg}"
              KAIROS_SANS_CHANGED=1
            fi
            return 0
          fi
          sed -i "/^[[:space:]]*api:/a\\    sans:\\\n    - ${api_ip}" "${cfg}"
          KAIROS_SANS_CHANGED=1
          return 0
        fi

        if grep -qE '^[[:space:]]*spec:' "${cfg}"; then
          sed -i "/^[[:space:]]*spec:/a\\  api:\\\n    sans:\\\n    - ${api_ip}" "${cfg}"
          KAIROS_SANS_CHANGED=1
          return 0
        fi

        printf '%s\n' \
          "spec:" \
          "  api:" \
          "    sans:" \
          "    - ${api_ip}" >> "${cfg}"
        KAIROS_SANS_CHANGED=1
        return 0
      }

      API_IP="$(detect_primary_ip || true)"
      ensure_k0s_api_sans "${API_IP}" || true

      if [ "${KAIROS_SANS_CHANGED}" = "1" ]; then
        echo "Updated k0s api.sans entries"
        KAIROS_REPUSH_KUBECONFIG=true
        # Force apiserver cert regeneration with updated SANs
        rm -f /var/lib/k0s/pki/apiserver.crt /var/lib/k0s/pki/apiserver.key || true
        if systemctl is-active --quiet k0scontroller; then
          systemctl restart k0scontroller || true
        else
          systemctl restart k0s || true
        fi
      fi
      {{- end }}
      
      {{- if .Manifests }}
      # Write k0s manifests
      echo "Writing k0s manifests..."
      mkdir -p /var/lib/k0s/manifests
      {{- range .Manifests }}
      mkdir -p /var/lib/k0s/manifests/{{ .Name }}
      cat > /var/lib/k0s/manifests/{{ .Name }}/{{ .File }} << 'MANIFEST_EOF'
{{ .Content }}
MANIFEST_EOF
      chmod 0644 /var/lib/k0s/manifests/{{ .Name }}/{{ .File }}
      echo "Written manifest: /var/lib/k0s/manifests/{{ .Name }}/{{ .File }}"
      {{- end }}
      {{- end }}
      
      {{- if .ProviderID }}
      # Wait for k0s to be ready and Node to be registered
      echo "Waiting for k0s node to be registered..."
      export KUBECONFIG=/var/lib/k0s/pki/admin.conf
      MAX_WAIT=300
      ELAPSED=0
      while ! kubectl get node $(hostname) &>/dev/null; do
        if [ $ELAPSED -ge $MAX_WAIT ]; then
          echo "ERROR: Timeout waiting for node to be registered"
          exit 1
        fi
        echo "Waiting for node to be registered... (${ELAPSED}s/${MAX_WAIT}s)"
        sleep 5
        ELAPSED=$((ELAPSED + 5))
      done
      
      # Set providerID on the Node
      # Retry in case of temporary API server unavailability
      echo "Setting providerID={{ .ProviderID }} on node $(hostname)..."
      PROVIDER_ID_SET=false
      for i in {1..30}; do
        if kubectl patch node $(hostname) --type=merge -p '{"spec":{"providerID":"{{ .ProviderID }}"}}' &>/dev/null; then
          echo "Successfully set providerID={{ .ProviderID }} on node $(hostname)"
          PROVIDER_ID_SET=true
          break
        fi
        echo "Attempt $i/30: Failed to set providerID, retrying in 5 seconds..."
        sleep 5
      done
      
      if [ "$PROVIDER_ID_SET" != "true" ]; then
        echo "ERROR: Failed to set providerID after 30 attempts"
        exit 1
      fi
      {{- else }}
      echo "No providerID to set"
      {{- end }}
      
      {{- if .ManagementKubeconfigToken }}
      # Push kubeconfig to management cluster without SSH (KubeVirt)
      push_kubeconfig() {
        local kubeconfig_file="/var/lib/k0s/pki/admin.conf"
        if [ ! -f "${kubeconfig_file}" ]; then
          echo "WARN: kubeconfig file not found at ${kubeconfig_file}"
          return 1
        fi
        if ! command -v curl >/dev/null 2>&1; then
          echo "WARN: curl not available; cannot push kubeconfig"
          return 1
        fi
        if ! command -v base64 >/dev/null 2>&1; then
          echo "WARN: base64 not available; cannot push kubeconfig"
          return 1
        fi
        local kubeconfig_b64
        kubeconfig_b64=$(base64 -w 0 "${kubeconfig_file}" 2>/dev/null || base64 "${kubeconfig_file}" | tr -d '\n')
        local api="{{ .ManagementAPIServer }}"
        local ns="{{ .ManagementKubeconfigSecretNamespace }}"
        local name="{{ .ManagementKubeconfigSecretName }}"
        local token="{{ .ManagementKubeconfigToken }}"
        local payload
        payload="{\"apiVersion\":\"v1\",\"kind\":\"Secret\",\"metadata\":{\"name\":\"${name}\",\"namespace\":\"${ns}\"},\"type\":\"cluster.x-k8s.io/secret\",\"data\":{\"value\":\"${kubeconfig_b64}\"}}"
        local url="${api}/api/v1/namespaces/${ns}/secrets/${name}"
        local status
        status=$(curl -k -sS -o /tmp/kairos-kubeconfig-push.log -w "%{http_code}" \
          -H "Authorization: Bearer ${token}" \
          -H "Content-Type: application/json" \
          -X PUT \
          --data "${payload}" \
          "${url}" || true)
        if [ "${status}" = "404" ]; then
          status=$(curl -k -sS -o /tmp/kairos-kubeconfig-push.log -w "%{http_code}" \
            -H "Authorization: Bearer ${token}" \
            -H "Content-Type: application/json" \
            -X POST \
            --data "${payload}" \
            "${api}/api/v1/namespaces/${ns}/secrets" || true)
        fi
        if [ "${status}" -ge 200 ] && [ "${status}" -lt 300 ]; then
          echo "Pushed kubeconfig to management secret ${ns}/${name}"
          return 0
        fi
        echo "WARN: failed to push kubeconfig to management cluster (status ${status})"
        return 1
      }
      if [ "${KAIROS_REPUSH_KUBECONFIG}" = "true" ]; then
        for i in {1..12}; do
          if push_kubeconfig; then
            break
          fi
          echo "Retrying kubeconfig push after cert update ($i/12)..."
          sleep 5
        done
      fi
      if ! push_kubeconfig; then
        echo "WARN: kubeconfig push failed; proceeding without blocking bootstrap"
      fi
      {{- end }}
      
      # Mark bootstrap success for CAPI/CAPK consumers
      # This file is used by Cluster API to determine bootstrap completion
      mkdir -p /run/cluster-api
      echo "success" > /run/cluster-api/bootstrap-success.complete
      chmod 0644 /run/cluster-api/bootstrap-success.complete
      
      echo "k0s post-bootstrap tasks completed successfully"
  {{- if eq .Role "control-plane" }}
  - path: /etc/systemd/system/kairos-k0s-lb-sans.service
    permissions: "0644"
    owner: 0
    group: 0
    content: |
      [Unit]
      Description=Ensure k0s apiserver SANs include LoadBalancer endpoint
      After=k0s.service
      Wants=k0s.service

      [Service]
      Type=oneshot
      RemainAfterExit=yes
      ExecStart=/usr/local/bin/kairos-k0s-lb-sans.sh
      Restart=on-failure
      RestartSec=15s
      StartLimitInterval=300s
      StartLimitBurst=40

      [Install]
      WantedBy=multi-user.target
  - path: /etc/systemd/system/kairos-k0s-lb-sans.path
    permissions: "0644"
    owner: 0
    group: 0
    content: |
      [Unit]
      Description=Watch for k0s config to update SANs

      [Path]
      PathExists=/etc/k0s/k0s.yaml
      PathChanged=/etc/k0s/k0s.yaml

      [Install]
      WantedBy=multi-user.target
  - path: /usr/local/bin/kairos-k0s-lb-sans.sh
    permissions: "0755"
    owner: 0
    group: 0
    content: |
      #!/bin/bash
      set -e

      {{- if .ControlPlaneLBEndpoint }}
      KAIROS_LB_ENDPOINT="{{ .ControlPlaneLBEndpoint }}"
      {{- end }}

      if [ -z "${KAIROS_LB_ENDPOINT}" ]; then
        echo "LB SAN updater disabled: LoadBalancer endpoint not provided"
        exit 0
      fi

      ensure_k0s_api_sans() {
        local api_ip="$1"
        if [ -z "${api_ip}" ]; then
          echo "Waiting for LoadBalancer endpoint..."
          return 1
        fi
        local cfg="/etc/k0s/k0s.yaml"
        if [ ! -f "${cfg}" ]; then
          echo "WARN: ${cfg} not found yet"
          return 1
        fi
        if grep -qE '^[[:space:]]*api:' "${cfg}"; then
          if grep -qE '^[[:space:]]*sans:' "${cfg}"; then
            if ! grep -qE '^[[:space:]]*-[[:space:]]*'"${api_ip}"'([[:space:]]|$)' "${cfg}"; then
              sed -i "/^[[:space:]]*sans:/a\\    - ${api_ip}" "${cfg}"
            fi
            return 0
          fi
          sed -i "/^[[:space:]]*api:/a\\    sans:\\\n    - ${api_ip}" "${cfg}"
          return 0
        fi

        if grep -qE '^[[:space:]]*spec:' "${cfg}"; then
          sed -i "/^[[:space:]]*spec:/a\\  api:\\\n    sans:\\\n    - ${api_ip}" "${cfg}"
          return 0
        fi

        printf '%s\n' \
          "spec:" \
          "  api:" \
          "    sans:" \
          "    - ${api_ip}" >> "${cfg}"
        return 0
      }

      if ensure_k0s_api_sans "${KAIROS_LB_ENDPOINT}"; then
        echo "Updated k0s api.sans with LoadBalancer endpoint: ${KAIROS_LB_ENDPOINT}"
        rm -f /var/lib/k0s/pki/apiserver.crt /var/lib/k0s/pki/apiserver.key || true
        if systemctl is-active --quiet k0scontroller; then
          systemctl restart k0scontroller || true
        else
          systemctl restart k0s || true
        fi
        exit 0
      fi
      exit 1
  {{- end }}
  {{- end }}
{{- end }}

{{- /* DNS overrides and post-bootstrap service */}}
stages:
  boot:
    - name: "Ensure SSH service is enabled"
      commands:
        - mkdir -p /etc/ssh/sshd_config.d
        - systemctl enable --now sshd || systemctl enable --now ssh || true
        - systemctl restart sshd || systemctl restart ssh || true
    - name: "Allow SSH password authentication"
      files:
        - path: /etc/ssh/sshd_config.d/60-kairos-capi.conf
          permissions: "0644"
          owner: 0
          group: 0
          content: |
            PasswordAuthentication yes
            KbdInteractiveAuthentication yes
    {{- if .DNSServers }}
    - name: "Configure DNS resolvers for early boot"
      dns:
        nameservers:
        {{- range .DNSServers }}
          - {{ . }}
        {{- end }}
        path: "/etc/resolv.conf"
    {{- end }}
    - name: "Create k0s post-bootstrap service and script"
      files:
        {{- if or .Hostname .HostnamePrefix }}
        - path: /usr/local/etc/hostname
          permissions: "0644"
          owner: 0
          group: 0
          content: |
            {{- if .Hostname }}
            {{ .Hostname }}
            {{- else }}
            {{ .HostnamePrefix }}{{ "{{ trunc 4 .MachineID }}" }}
            {{- end }}
        {{- end }}
        - path: /etc/systemd/system/kairos-k0s-post-bootstrap.service
          permissions: "0644"
          owner: 0
          group: 0
          content: |
            [Unit]
            Description=Kairos k0s post-bootstrap tasks
            {{- if eq .Role "control-plane" }}
            After=k0s.service
            Wants=k0s.service
            {{- else }}
            After=k0s-worker.service
            Wants=k0s-worker.service
            {{- end }}
            
            [Service]
            Type=oneshot
            RemainAfterExit=yes
            ExecStart=/usr/local/bin/kairos-k0s-post-bootstrap.sh
            
            [Install]
            WantedBy=multi-user.target
        - path: /usr/local/bin/kairos-k0s-post-bootstrap.sh
          permissions: "0755"
          owner: 0
          group: 0
          content: |
            #!/bin/bash
            set -e
            
            {{- if .IsKubeVirt }}
            # CAPK: always mark bootstrap success on script exit
            mark_bootstrap_success() {
              mkdir -p /run/cluster-api
              echo "success" > /run/cluster-api/bootstrap-success.complete
              chmod 0644 /run/cluster-api/bootstrap-success.complete
            }
            trap mark_bootstrap_success EXIT
            {{- end }}
            
            {{- if .HostnamePrefix }}
            # Enforce hostname from cloud-config on immutable rootfs
            if [ -f /usr/local/etc/hostname ]; then
              /usr/bin/hostnamectl set-hostname "$(cat /usr/local/etc/hostname)"
              if ! grep -qE "127\.0\.1\.1[[:space:]]+$(cat /usr/local/etc/hostname)" /etc/hosts; then
                echo "127.0.1.1 $(cat /usr/local/etc/hostname)" >> /etc/hosts
              fi
            fi
            {{- end }}
            
            {{- if .ProviderID }}
            # Wait for k0s to be ready and Node to be registered
            echo "Waiting for k0s node to be registered..."
            export KUBECONFIG=/var/lib/k0s/pki/admin.conf
            MAX_WAIT=300
            ELAPSED=0
            NODE_REGISTERED=false
            while ! k0s kubectl --kubeconfig /var/lib/k0s/pki/admin.conf get node $(hostname) &>/dev/null; do
              if [ $ELAPSED -ge $MAX_WAIT ]; then
                echo "WARN: Timeout waiting for node to be registered"
                break
              fi
              echo "Waiting for node to be registered... (${ELAPSED}s/${MAX_WAIT}s)"
              sleep 5
              ELAPSED=$((ELAPSED + 5))
            done
            if k0s kubectl --kubeconfig /var/lib/k0s/pki/admin.conf get node $(hostname) &>/dev/null; then
              NODE_REGISTERED=true
            fi
            
            # Set providerID on the Node
            # Retry in case of temporary API server unavailability
            if [ "$NODE_REGISTERED" = "true" ]; then
              echo "Setting providerID={{ .ProviderID }} on node $(hostname)..."
              PROVIDER_ID_SET=false
              for i in {1..30}; do
                if k0s kubectl --kubeconfig /var/lib/k0s/pki/admin.conf patch node $(hostname) --type=merge -p '{"spec":{"providerID":"{{ .ProviderID }}"}}' &>/dev/null; then
                  echo "Successfully set providerID={{ .ProviderID }} on node $(hostname)"
                  PROVIDER_ID_SET=true
                  break
                fi
                echo "Attempt $i/30: Failed to set providerID, retrying in 5 seconds..."
                sleep 5
              done
              if [ "$PROVIDER_ID_SET" != "true" ]; then
                echo "WARN: Failed to set providerID after 30 attempts"
              fi
            else
              echo "WARN: Node not registered; skipping providerID patch"
            fi
            {{- else }}
            echo "No providerID to set"
            {{- end }}
            
            # Mark bootstrap success for CAPI/CAPK consumers
            # This file is used by Cluster API to determine bootstrap completion
            mkdir -p /run/cluster-api
            echo "success" > /run/cluster-api/bootstrap-success.complete
            chmod 0644 /run/cluster-api/bootstrap-success.complete
            
            echo "k0s post-bootstrap tasks completed successfully"
      commands:
        - systemctl daemon-reload || true
        - systemctl enable kairos-k0s-post-bootstrap.service || true
        - systemctl start kairos-k0s-post-bootstrap.service || true
    - name: "Ensure SSH service is enabled"
      commands:
        - mkdir -p /etc/ssh/sshd_config.d
        - systemctl enable --now sshd || systemctl enable --now ssh || true
        - systemctl restart sshd || systemctl restart ssh || true
    - name: "Allow SSH password authentication"
      files:
        - path: /etc/ssh/sshd_config.d/60-kairos-capi.conf
          permissions: "0644"
          owner: 0
          group: 0
          content: |
            PasswordAuthentication yes
            KbdInteractiveAuthentication yes
    {{- if .DNSServers }}
    - name: "Configure DNS resolvers for early boot"
      dns:
        nameservers:
        {{- range .DNSServers }}
          - {{ . }}
        {{- end }}
        path: "/etc/resolv.conf"
    {{- end }}
    - name: "Create k0s post-bootstrap service and script"
      files:
        {{- if or .Hostname .HostnamePrefix }}
        - path: /usr/local/etc/hostname
          permissions: "0644"
          owner: 0
          group: 0
          content: |
            {{- if .Hostname }}
            {{ .Hostname }}
            {{- else }}
            {{ .HostnamePrefix }}{{ "{{ trunc 4 .MachineID }}" }}
            {{- end }}
        {{- end }}
        - path: /etc/systemd/system/kairos-k0s-post-bootstrap.service
          permissions: "0644"
          owner: 0
          group: 0
          content: |
            [Unit]
            Description=Kairos k0s post-bootstrap tasks
            {{- if eq .Role "control-plane" }}
            After=k0s.service
            Wants=k0s.service
            {{- else }}
            After=k0s-worker.service
            Wants=k0s-worker.service
            {{- end }}
            
            [Service]
            Type=oneshot
            RemainAfterExit=yes
            ExecStart=/usr/local/bin/kairos-k0s-post-bootstrap.sh
            
            [Install]
            WantedBy=multi-user.target
        - path: /usr/local/bin/kairos-k0s-post-bootstrap.sh
          permissions: "0755"
          owner: 0
          group: 0
          content: |
            #!/bin/bash
            set -e
            
            {{- if .IsKubeVirt }}
            # CAPK: always mark bootstrap success on script exit
            mark_bootstrap_success() {
              mkdir -p /run/cluster-api
              echo "success" > /run/cluster-api/bootstrap-success.complete
              chmod 0644 /run/cluster-api/bootstrap-success.complete
            }
            trap mark_bootstrap_success EXIT
            {{- end }}
            
            {{- if .HostnamePrefix }}
            # Enforce hostname from cloud-config on immutable rootfs
            if [ -f /usr/local/etc/hostname ]; then
              /usr/bin/hostnamectl set-hostname "$(cat /usr/local/etc/hostname)"
              if ! grep -qE "127\.0\.1\.1[[:space:]]+$(cat /usr/local/etc/hostname)" /etc/hosts; then
                echo "127.0.1.1 $(cat /usr/local/etc/hostname)" >> /etc/hosts
              fi
            fi
            {{- end }}
            
            {{- if .Manifests }}
            # Write k0s manifests
            echo "Writing k0s manifests..."
            mkdir -p /var/lib/k0s/manifests
            {{- range .Manifests }}
            mkdir -p /var/lib/k0s/manifests/{{ .Name }}
            cat > /var/lib/k0s/manifests/{{ .Name }}/{{ .File }} << 'MANIFEST_EOF'
{{ .Content }}
MANIFEST_EOF
            chmod 0644 /var/lib/k0s/manifests/{{ .Name }}/{{ .File }}
            echo "Written manifest: /var/lib/k0s/manifests/{{ .Name }}/{{ .File }}"
            {{- end }}
            {{- end }}
            
            {{- if .ProviderID }}
            # Wait for k0s to be ready and Node to be registered
            echo "Waiting for k0s node to be registered..."
            export KUBECONFIG=/var/lib/k0s/pki/admin.conf
            MAX_WAIT=300
            ELAPSED=0
            NODE_REGISTERED=false
            while ! k0s kubectl --kubeconfig /var/lib/k0s/pki/admin.conf get node $(hostname) &>/dev/null; do
              if [ $ELAPSED -ge $MAX_WAIT ]; then
                echo "WARN: Timeout waiting for node to be registered"
                break
              fi
              echo "Waiting for node to be registered... (${ELAPSED}s/${MAX_WAIT}s)"
              sleep 5
              ELAPSED=$((ELAPSED + 5))
            done
            if k0s kubectl --kubeconfig /var/lib/k0s/pki/admin.conf get node $(hostname) &>/dev/null; then
              NODE_REGISTERED=true
            fi
            
            # Set providerID on the Node
            # Retry in case of temporary API server unavailability
            if [ "$NODE_REGISTERED" = "true" ]; then
              echo "Setting providerID={{ .ProviderID }} on node $(hostname)..."
              PROVIDER_ID_SET=false
              for i in {1..30}; do
                if k0s kubectl --kubeconfig /var/lib/k0s/pki/admin.conf patch node $(hostname) --type=merge -p '{"spec":{"providerID":"{{ .ProviderID }}"}}' &>/dev/null; then
                  echo "Successfully set providerID={{ .ProviderID }} on node $(hostname)"
                  PROVIDER_ID_SET=true
                  break
                fi
                echo "Attempt $i/30: Failed to set providerID, retrying in 5 seconds..."
                sleep 5
              done
              if [ "$PROVIDER_ID_SET" != "true" ]; then
                echo "WARN: Failed to set providerID after 30 attempts"
              fi
            else
              echo "WARN: Node not registered; skipping providerID patch"
            fi
            {{- else }}
            echo "No providerID to set"
            {{- end }}
            
            {{- if and (eq .Role "control-plane") (eq .ControlPlaneMode "init") (not .SingleNode) }}
            # Publish controller join token into the workload cluster (init node only)
            echo "Ensuring controller join token Secret exists in workload cluster..."
            for i in {1..30}; do
              if k0s kubectl --kubeconfig /var/lib/k0s/pki/admin.conf -n kairos-system get secret k0s-controller-join-token >/dev/null 2>&1; then
                echo "Join token Secret already exists."
                break
              fi
              if k0s kubectl --kubeconfig /var/lib/k0s/pki/admin.conf get --raw /readyz >/dev/null 2>&1; then
                TOKEN="$(k0s token create --role=controller)"
                k0s kubectl --kubeconfig /var/lib/k0s/pki/admin.conf \
                  create namespace kairos-system --dry-run=client -o yaml | k0s kubectl apply -f -
                k0s kubectl --kubeconfig /var/lib/k0s/pki/admin.conf -n kairos-system \
                  create secret generic k0s-controller-join-token \
                  --from-literal=token="${TOKEN}" \
                  --dry-run=client -o yaml | k0s kubectl apply -f -
                echo "Join token Secret created."
                break
              fi
              echo "Waiting for k0s API to be ready for join token creation..."
              sleep 10
            done
            {{- end }}
            
            {{- if .ManagementKubeconfigToken }}
            # Push kubeconfig to management cluster without SSH (KubeVirt)
            push_kubeconfig() {
              local kubeconfig_file="/var/lib/k0s/pki/admin.conf"
              if [ ! -f "${kubeconfig_file}" ]; then
                echo "WARN: kubeconfig file not found at ${kubeconfig_file}"
                return 1
              fi
              if ! command -v curl >/dev/null 2>&1; then
                echo "WARN: curl not available; cannot push kubeconfig"
                return 1
              fi
              if ! command -v base64 >/dev/null 2>&1; then
                echo "WARN: base64 not available; cannot push kubeconfig"
                return 1
              fi
              local kubeconfig_b64
              kubeconfig_b64=$(base64 -w 0 "${kubeconfig_file}" 2>/dev/null || base64 "${kubeconfig_file}" | tr -d '\n')
              local api="{{ .ManagementAPIServer }}"
              local ns="{{ .ManagementKubeconfigSecretNamespace }}"
              local name="{{ .ManagementKubeconfigSecretName }}"
              local token="{{ .ManagementKubeconfigToken }}"
              local payload
              payload="{\"apiVersion\":\"v1\",\"kind\":\"Secret\",\"metadata\":{\"name\":\"${name}\",\"namespace\":\"${ns}\"},\"type\":\"cluster.x-k8s.io/secret\",\"data\":{\"value\":\"${kubeconfig_b64}\"}}"
              local url="${api}/api/v1/namespaces/${ns}/secrets/${name}"
              local status
              status=$(curl -k -sS -o /tmp/kairos-kubeconfig-push.log -w "%{http_code}" \
                -H "Authorization: Bearer ${token}" \
                -H "Content-Type: application/json" \
                -X PUT \
                --data "${payload}" \
                "${url}" || true)
              if [ "${status}" = "404" ]; then
                status=$(curl -k -sS -o /tmp/kairos-kubeconfig-push.log -w "%{http_code}" \
                  -H "Authorization: Bearer ${token}" \
                  -H "Content-Type: application/json" \
                  -X POST \
                  --data "${payload}" \
                  "${api}/api/v1/namespaces/${ns}/secrets" || true)
              fi
              if [ "${status}" -ge 200 ] && [ "${status}" -lt 300 ]; then
                echo "Pushed kubeconfig to management secret ${ns}/${name}"
                return 0
              fi
              echo "WARN: failed to push kubeconfig to management cluster (status ${status})"
              return 1
            }
            if [ "${KAIROS_REPUSH_KUBECONFIG}" = "true" ]; then
              for i in {1..12}; do
                if push_kubeconfig; then
                  break
                fi
                echo "Retrying kubeconfig push after cert update ($i/12)..."
                sleep 5
              done
            fi
            if ! push_kubeconfig; then
              echo "WARN: kubeconfig push failed; proceeding without blocking bootstrap"
            fi
            {{- end }}
            
            # Mark bootstrap success for CAPI/CAPK consumers
            # This file is used by Cluster API to determine bootstrap completion
            mkdir -p /run/cluster-api
            echo "success" > /run/cluster-api/bootstrap-success.complete
            chmod 0644 /run/cluster-api/bootstrap-success.complete
            
            echo "k0s post-bootstrap tasks completed successfully"
      commands:
        - systemctl daemon-reload
        - systemctl enable --now kairos-k0s-post-bootstrap.service || true

runcmd:
{{- if .IsKubeVirt }}
  - /bin/systemctl daemon-reload || true
  - /bin/systemctl enable kairos-k0s-post-bootstrap.service || true
  - /bin/systemctl start kairos-k0s-post-bootstrap.service || true
  {{- if eq .Role "control-plane" }}
  - /bin/systemctl enable kairos-k0s-lb-sans.path || true
  - /bin/systemctl start kairos-k0s-lb-sans.path || true
  {{- end }}
{{- end }}
